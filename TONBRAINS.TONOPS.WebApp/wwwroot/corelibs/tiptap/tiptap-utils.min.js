
    /*!
    * tiptap-utils v1.2.0
    * (c) 2019 Scrumpy UG (limited liability)
    * @license MIT
    */


!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("prosemirror-utils")):"function"==typeof define&&define.amd?define(["exports","/libs/tipTap/prosemirror-utils.js"],r):r((e=e||self).tiptap={},e.prosemirrorUtils)}(this,function(e,o){"use strict";function f(e){return function(e){if(Array.isArray(e)){for(var r=0,t=new Array(e.length);r<e.length;r++)t[r]=e[r];return t}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}e.getMarkAttrs=function(e,r){var t=e.selection,n=t.from,o=t.to,i=[];e.doc.nodesBetween(n,o,function(e){i=f(i).concat(f(e.marks))});var a=i.find(function(e){return e.type.name===r.name});return a?a.attrs:{}},e.getMarkRange=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;if(!e||!r)return!1;var t=e.parent.childAfter(e.parentOffset);if(!t.node)return!1;var n=t.node.marks.find(function(e){return e.type===r});if(!n)return!1;for(var o=e.index(),i=e.start()+t.offset;0<o&&n.isInSet(e.parent.child(o-1).marks);)o-=1,i-=e.parent.child(o).nodeSize;return{from:i,to:i+t.node.nodeSize}},e.markIsActive=function(e,r){var t=e.selection,n=t.from,o=t.$from,i=t.to;return t.empty?!!r.isInSet(e.storedMarks||o.marks()):!!e.doc.rangeHasMark(n,i,r)},e.nodeIsActive=function(e,r){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{},n=o.findParentNode(function(e){return e.type===r})(e.selection);return Object.keys(t).length&&n?n.node.hasMarkup(r,t):!!n},Object.defineProperty(e,"__esModule",{value:!0})});